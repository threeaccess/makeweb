#!/usr/bin/env python3
"""Make Web: Convert a Markdown file into a well-formatted HTML file."""

from __future__ import annotations

import argparse
import json
import pathlib
import re
import shutil
import sys
from collections import OrderedDict
from string import Template
from typing import Optional, List


# Paths
TOOLS_DIR = pathlib.Path(__file__).parent.resolve()
TEMPLATES_DIR = TOOLS_DIR / "templates"
STYLES_SRC_DIR = TOOLS_DIR / "styles"
THEMES_CONFIG_PATH = TOOLS_DIR / "themes.json"


def _infer_title(markdown_text: str, fallback: str) -> str:
    """Extract title from first H1 heading."""
    for line in markdown_text.splitlines():
        if line.startswith("# "):
            return line[2:].strip()
    return fallback


def _extract_title_from_html(html_path: pathlib.Path) -> str:
    """Extract title from an HTML file's <title> tag, falling back to filename."""
    try:
        content = html_path.read_text(encoding="utf-8")
        match = re.search(r"<title>(.*?)</title>", content, re.IGNORECASE | re.DOTALL)
        if match:
            return match.group(1).strip()
    except (OSError, UnicodeDecodeError):
        pass
    return html_path.stem


def _load_markdown_converter():
    """Load and configure the Markdown converter."""
    try:
        import markdown  # type: ignore
    except ModuleNotFoundError as exc:
        msg = (
            "Missing dependency: 'markdown'.\n"
            "Install it with: python -m pip install markdown\n"
        )
        raise RuntimeError(msg) from exc

    return markdown.Markdown(
        extensions=[
            "extra",
            "tables",
            "fenced_code",
            "sane_lists",
            "toc",
            "codehilite",
        ]
    )


def load_template(template_name: str) -> Template:
    """Load HTML template from file."""
    template_path = TEMPLATES_DIR / f"{template_name}_template.html"
    if not template_path.exists():
        raise RuntimeError(f"Template not found: {template_path}")
    return Template(template_path.read_text(encoding="utf-8"))


def validate_paths() -> bool:
    """Validate required directories and files exist.

    Returns:
        True if all paths are valid, False otherwise.
    """
    errors = []

    if not STYLES_SRC_DIR.exists():
        errors.append(f"Styles directory not found: {STYLES_SRC_DIR}")

    if not TEMPLATES_DIR.exists():
        errors.append(f"Templates directory not found: {TEMPLATES_DIR}")

    # Check for required CSS files
    required_css = ["core.css", "content.css"]
    for css_file in required_css:
        css_path = STYLES_SRC_DIR / css_file
        if not css_path.exists():
            errors.append(f"Required CSS file not found: {css_path}")

    if errors:
        print("Error: Missing required files/directories:", file=sys.stderr)
        for error in errors:
            print(f"  - {error}", file=sys.stderr)
        return False

    return True


def discover_themes() -> List[dict]:
    """Auto-discover all theme CSS files from the bundled styles directory."""
    themes = []

    if not STYLES_SRC_DIR.exists():
        return themes

    for css_file in sorted(STYLES_SRC_DIR.glob("theme-*.css")):
        theme_id = css_file.stem.replace("theme-", "")
        theme_name = theme_id.replace("-", " ").title()

        # Check if theme supports dark mode
        css_content = css_file.read_text(encoding="utf-8")
        supports_dark = '[data-color-scheme="dark"]' in css_content

        themes.append({
            "id": theme_id,
            "name": theme_name,
            "css_url": f"styles/theme-{theme_id}.css",
            "supports_dark": supports_dark,
        })

    return themes


def load_themes_config() -> dict:
    """Load themes configuration and merge with discovered themes."""
    discovered = discover_themes()

    if THEMES_CONFIG_PATH.exists():
        config = json.loads(THEMES_CONFIG_PATH.read_text(encoding="utf-8"))
    else:
        config = {}

    # Merge discovered themes with config
    theme_lookup = {t["id"]: t for t in discovered}

    # Override with any custom config
    for theme_id, theme_config in config.get("themes", {}).items():
        if theme_id in theme_lookup:
            theme_lookup[theme_id]["name"] = theme_config.get("name", theme_lookup[theme_id]["name"])

    return {
        "default_theme": config.get("default_theme", "modern"),
        "themes": list(theme_lookup.values()),
        "page_types": config.get("page_types", {
            "content": {
                "css_file": "content.css",
                "template": "content_template.html",
                "badge_default": "Documentation",
                "subtitle_default": "Generated by Make Web",
            }
        }),
    }


def generate_theme_css_links(themes: List[dict]) -> str:
    """Generate HTML link tags for all theme CSS files."""
    links = []
    for theme in themes:
        links.append(f'<link rel="stylesheet" href="{theme["css_url"]}">')
    return "\n  ".join(links)


def generate_theme_selector_options(themes: List[dict], default_theme: str) -> str:
    """Generate HTML option tags for theme selector dropdown."""
    options = []
    for theme in themes:
        selected = " selected" if theme["id"] == default_theme else ""
        options.append(f'<option value="{theme["id"]}"{selected}>{theme["name"]}</option>')
    
    return "\n            ".join(options)


def _build_nav_html(index_url: Optional[str]) -> str:
    """Build the nav element if an index URL is provided, otherwise empty string."""
    if not index_url:
        return ""
    return (
        '<nav class="page-nav">\n'
        f'      <a href="{index_url}">Notes Index</a>\n'
        '    </nav>'
    )


def _build_html(
    title: str,
    body_html: str,
    toc_html: Optional[str],
    standalone: bool = False,
    badge: str = "Documentation",
    subtitle: Optional[str] = None,
    index_url: Optional[str] = None,
    styles_prefix: Optional[str] = None,
) -> str:
    """Build HTML using template system."""

    if standalone:
        return _build_standalone_html(title, body_html, toc_html, badge, subtitle, index_url)

    # Load template and config
    template = load_template("content")
    config = load_themes_config()
    themes = config["themes"]
    default_theme = config["default_theme"]

    # Use default subtitle if not provided
    if subtitle is None:
        page_config = config.get("page_types", {}).get("content", {})
        subtitle = page_config.get("subtitle_default", "Generated by Make Web")

    # Allow overriding the styles path prefix (e.g. for buildsite depth-adjusted paths)
    sp = styles_prefix if styles_prefix else "styles"

    # Rewrite theme CSS urls if custom prefix
    if styles_prefix:
        for theme in themes:
            theme["css_url"] = f"{sp}/theme-{theme['id']}.css"

    # Generate CSS links and theme selector
    theme_css_links = generate_theme_css_links(themes)
    theme_selector_options = generate_theme_selector_options(themes, default_theme)

    # Template variables
    template_vars = {
        "title": title,
        "default_theme": default_theme,
        "theme_selector_options": theme_selector_options,
        "theme_css_links": theme_css_links,
        "css_core": f"{sp}/core.css",
        "css_page": f"{sp}/content.css",
        "nav_html": _build_nav_html(index_url),
        "badge_text": badge,
        "subtitle": subtitle,
        "toc_html": toc_html if toc_html else "",
        "body_html": body_html,
    }

    return template.safe_substitute(template_vars)


def _build_standalone_html(
    title: str,
    body_html: str,
    toc_html: Optional[str],
    badge: str,
    subtitle: Optional[str],
    index_url: Optional[str] = None,
) -> str:
    """Build self-contained HTML with inline CSS and theme switching."""
    themes = discover_themes()
    default_theme = "modern"

    # Inline all CSS
    css_parts = []

    core_css_path = STYLES_SRC_DIR / "core.css"
    if core_css_path.exists():
        css_parts.append(core_css_path.read_text(encoding="utf-8"))

    for css_file in sorted(STYLES_SRC_DIR.glob("theme-*.css")):
        css_content = css_file.read_text(encoding="utf-8")
        css_parts.append(f"/* {css_file.name} */\n{css_content}")

    content_css_path = STYLES_SRC_DIR / "content.css"
    if content_css_path.exists():
        css_parts.append(content_css_path.read_text(encoding="utf-8"))

    combined_css = "\n\n".join(css_parts)

    theme_selector_options = generate_theme_selector_options(themes, default_theme)
    nav_html = _build_nav_html(index_url)

    # Build nav block with proper indentation (or empty)
    nav_block = f"    {nav_html}\n    " if nav_html else ""

    # Build inline HTML
    return f"""<!DOCTYPE html>
<html lang="en" data-theme-name="{default_theme}" data-page-type="content">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{title}</title>
  <style>{combined_css}</style>
</head>
<body>
  <div class="container">
    {nav_block}
    <div class="header-wrapper">
      <div class="header-card">
        <div class="header-accent-bar"></div>
        <div class="header-content">
          <div class="header-title-group">
            <div class="header-badge">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
                <polyline points="10 9 9 9 8 9"/>
              </svg>
              {badge}
            </div>
            <h1 class="gradient-title">{title}</h1>
            <p class="subtitle">{subtitle}</p>
          </div>

          <!-- Width Toggle -->
          <button class="width-toggle" aria-label="Toggle full width" title="Toggle full width">
            <svg class="icon-expand" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
            </svg>
            <svg class="icon-collapse" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/>
            </svg>
          </button>

          <!-- Color Scheme Toggle -->
          <div class="theme-toggle" role="group" aria-label="Theme toggle">
            <button class="theme-btn active" data-color-scheme="light" aria-label="Light mode" title="Light mode">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="5"/>
                <line x1="12" y1="1" x2="12" y2="3"/>
                <line x1="12" y1="21" x2="12" y2="23"/>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                <line x1="1" y1="12" x2="3" y2="12"/>
                <line x1="21" y1="12" x2="23" y2="12"/>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
              </svg>
            </button>
            <button class="theme-btn" data-color-scheme="dark" aria-label="Dark mode" title="Dark mode">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
              </svg>
            </button>
          </div>

          <!-- Theme Selector -->
          <select id="theme-selector" class="theme-selector" aria-label="Select theme">
            {theme_selector_options}
          </select>
        </div>
      </div>
    </div>

    <div class="toc-wrapper">
      <aside class="toc-card">
        <div class="toc-header">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="8" y1="6" x2="21" y2="6"/>
            <line x1="8" y1="12" x2="21" y2="12"/>
            <line x1="8" y1="18" x2="21" y2="18"/>
            <line x1="3" y1="6" x2="3.01" y2="6"/>
            <line x1="3" y1="12" x2="3.01" y2="12"/>
            <line x1="3" y1="18" x2="3.01" y2="18"/>
          </svg>
          <span class="toc-title">Table of Contents</span>
        </div>
        <div class="toc">{toc_html if toc_html else ""}</div>
      </aside>
    </div>

    <div class="content-wrapper">
      <main>
        <article>{body_html}</article>
      </main>
    </div>
  </div>

  <script>
    // Width Toggle Functionality
    (function() {{
      const widthToggle = document.querySelector('.width-toggle');
      const html = document.documentElement;
      const body = document.body;

      const savedWidth = localStorage.getItem('page-width') || 'normal';
      if (savedWidth === 'wide') {{
        html.setAttribute('data-width', 'wide');
        body.classList.add('width-wide');
      }}

      if (widthToggle) {{
        widthToggle.addEventListener('click', () => {{
          const isWide = html.getAttribute('data-width') === 'wide' || body.classList.contains('width-wide');
          if (isWide) {{
            html.setAttribute('data-width', 'normal');
            body.classList.remove('width-wide');
            localStorage.setItem('page-width', 'normal');
          }} else {{
            html.setAttribute('data-width', 'wide');
            body.classList.add('width-wide');
            localStorage.setItem('page-width', 'wide');
          }}
        }});
      }}
    }})();

    // Color Scheme Toggle Functionality (Light/Dark)
    (function() {{
      const themeBtns = document.querySelectorAll('.theme-btn');
      const html = document.documentElement;

      const savedColorScheme = localStorage.getItem('color-scheme') || 'light';
      html.setAttribute('data-color-scheme', savedColorScheme);
      updateThemeButtons(savedColorScheme);

      themeBtns.forEach(btn => {{
        btn.addEventListener('click', () => {{
          const colorScheme = btn.getAttribute('data-color-scheme');
          html.setAttribute('data-color-scheme', colorScheme);
          localStorage.setItem('color-scheme', colorScheme);
          updateThemeButtons(colorScheme);
        }});
      }});

      function updateThemeButtons(activeColorScheme) {{
        themeBtns.forEach(btn => {{
          btn.classList.toggle('active', btn.getAttribute('data-color-scheme') === activeColorScheme);
        }});
      }}

      if (!localStorage.getItem('color-scheme')) {{
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const colorScheme = prefersDark ? 'dark' : 'light';
        html.setAttribute('data-color-scheme', colorScheme);
        localStorage.setItem('color-scheme', colorScheme);
        updateThemeButtons(colorScheme);
      }}

      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {{
        if (!localStorage.getItem('color-scheme')) {{
          const colorScheme = e.matches ? 'dark' : 'light';
          html.setAttribute('data-color-scheme', colorScheme);
          updateThemeButtons(colorScheme);
        }}
      }});
    }})();

    // Theme Name Selector Functionality
    (function() {{
      const themeSelector = document.getElementById('theme-selector');
      const html = document.documentElement;

      if (themeSelector) {{
        const savedThemeName = localStorage.getItem('theme-name');
        if (savedThemeName) {{
          html.setAttribute('data-theme-name', savedThemeName);
          themeSelector.value = savedThemeName;
        }}

        themeSelector.addEventListener('change', () => {{
          const themeName = themeSelector.value;
          html.setAttribute('data-theme-name', themeName);
          localStorage.setItem('theme-name', themeName);
        }});
      }}
    }})();
  </script>
</body>
</html>"""


def _build_site_index(
    entries: List[dict],
    output_path: pathlib.Path,
    styles_prefix: str,
    orphan_entries: Optional[List[dict]] = None,
) -> None:
    """Generate the buildsite index.html from collected entries."""
    template = load_template("buildsite_index")
    config = load_themes_config()
    themes = config["themes"]
    default_theme = config["default_theme"]

    # Rewrite theme CSS urls to point into html/styles/
    for theme in themes:
        theme["css_url"] = f"{styles_prefix}/theme-{theme['id']}.css"

    theme_css_links = generate_theme_css_links(themes)
    theme_selector_options = generate_theme_selector_options(themes, default_theme)

    # Group entries by directory
    groups: dict[str, list] = OrderedDict()
    for entry in sorted(entries, key=lambda e: (e["directory"], e["title"].lower())):
        groups.setdefault(entry["directory"], []).append(entry)

    # Build table rows
    dir_count = len(groups)
    file_count = len(entries)
    rows: list[str] = []
    for directory, files in groups.items():
        display_dir = directory if directory != "." else "Root"
        rows.append(
            f'<tr class="dir-header">'
            f'<td colspan="2">'
            f'<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">'
            f'<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>'
            f'</svg>'
            f'{display_dir}'
            f'</td></tr>'
        )
        for entry in files:
            rows.append(
                f'<tr class="file-row">'
                f'<td>'
                f'<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">'
                f'<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>'
                f'<polyline points="14 2 14 8 20 8"/>'
                f'<line x1="16" y1="13" x2="8" y2="13"/>'
                f'<line x1="16" y1="17" x2="8" y2="17"/>'
                f'<polyline points="10 9 9 9 8 9"/>'
                f'</svg>'
                f'<a href="{entry["html_rel_path"]}">{entry["title"]}</a>'
                f'</td>'
                f'<td><span class="source-path">{entry["source_rel_path"]}</span></td>'
                f'</tr>'
            )

    # Stats
    stats_html = (
        f'<span class="stat-item">'
        f'<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">'
        f'<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>'
        f'<polyline points="14 2 14 8 20 8"/>'
        f'</svg>'
        f'{file_count} document{"s" if file_count != 1 else ""}'
        f'</span>'
        f'<span class="stat-item">'
        f'<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">'
        f'<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>'
        f'</svg>'
        f'{dir_count} director{"ies" if dir_count != 1 else "y"}'
        f'</span>'
    )

    # Add orphan/deleted stat badge if applicable
    if orphan_entries:
        orphan_count = len(orphan_entries)
        stats_html += (
            f'<a href="#deleted-files" class="stat-item" style="text-decoration:none;color:inherit;">'
            f'<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">'
            f'<polyline points="3 6 5 6 21 6"/>'
            f'<path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>'
            f'</svg>'
            f'{orphan_count} deleted'
            f'</a>'
        )

    # Build deleted-files section HTML
    deleted_section_html = ""
    if orphan_entries:
        orphan_groups: dict[str, list] = OrderedDict()
        for entry in sorted(orphan_entries, key=lambda e: (e["directory"], e["title"].lower())):
            orphan_groups.setdefault(entry["directory"], []).append(entry)

        del_rows: list[str] = []
        for directory, files in orphan_groups.items():
            display_dir = directory if directory != "." else "Root"
            del_rows.append(
                f'<tr class="dir-header">'
                f'<td colspan="2">'
                f'<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">'
                f'<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>'
                f'</svg>'
                f'{display_dir}'
                f'</td></tr>'
            )
            for entry in files:
                del_rows.append(
                    f'<tr class="file-row">'
                    f'<td>'
                    f'<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">'
                    f'<polyline points="3 6 5 6 21 6"/>'
                    f'<path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>'
                    f'</svg>'
                    f'<a href="{entry["html_rel_path"]}">{entry["title"]}</a>'
                    f'</td>'
                    f'<td><span class="source-path">source deleted</span></td>'
                    f'</tr>'
                )

        deleted_section_html = (
            '\n    <div class="table-wrapper" id="deleted-files">\n'
            '      <div class="table-header">\n'
            '        <div class="table-title">\n'
            '          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">\n'
            '            <polyline points="3 6 5 6 21 6"/>\n'
            '            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>\n'
            '          </svg>\n'
            '          Deleted Files\n'
            '        </div>\n'
            '      </div>\n'
            '\n'
            '      <table>\n'
            '        <thead>\n'
            '          <tr>\n'
            '            <th>Title</th>\n'
            '            <th>Status</th>\n'
            '          </tr>\n'
            '        </thead>\n'
            '        <tbody>\n'
            '          ' + "\n          ".join(del_rows) + '\n'
            '        </tbody>\n'
            '      </table>\n'
            '    </div>'
        )

    template_vars = {
        "title": "Site Index",
        "subtitle": "Auto-generated document index",
        "default_theme": default_theme,
        "theme_selector_options": theme_selector_options,
        "theme_css_links": theme_css_links,
        "css_core": f"{styles_prefix}/core.css",
        "css_page": f"{styles_prefix}/index.css",
        "stats_html": stats_html,
        "table_rows_html": "\n          ".join(rows),
        "deleted_section_html": deleted_section_html,
    }

    output_path.write_text(template.safe_substitute(template_vars), encoding="utf-8")


def build_site(force: bool = False) -> int:
    """Batch-convert all .md files in cwd to HTML and generate an index.

    When *force* is False (the default), files whose HTML output is already
    up-to-date (output mtime >= source mtime) are skipped — like ``make``.
    """
    scan_dir = pathlib.Path(".")
    output_dir = scan_dir / "html"
    output_dir.mkdir(exist_ok=True)

    # Copy styles into output dir
    styles_dest = output_dir / "styles"
    shutil.copytree(STYLES_SRC_DIR, styles_dest, dirs_exist_ok=True)

    # Resolve output_dir so we can skip it during scanning
    output_dir_resolved = output_dir.resolve()

    # Collect all .md files, skipping the output directory
    md_files = []
    for md_path in scan_dir.rglob("*.md"):
        try:
            if md_path.resolve().is_relative_to(output_dir_resolved):
                continue
        except (ValueError, AttributeError):
            # is_relative_to not available on older Python — fall back
            try:
                md_path.resolve().relative_to(output_dir_resolved)
                continue
            except ValueError:
                pass
        md_files.append(md_path)

    if not md_files:
        print("No .md files found in current directory.", file=sys.stderr)
        return 1

    try:
        # Test that markdown library is available
        _load_markdown_converter()
    except RuntimeError as exc:
        print(str(exc), file=sys.stderr)
        return 1

    entries: List[dict] = []
    converted = 0
    skipped = 0

    for md_path in sorted(md_files):
        # --- cheap metadata (always) ---
        markdown_text = md_path.read_text(encoding="utf-8")
        title = _infer_title(markdown_text, md_path.stem)

        # Mirror source structure inside html/
        source_rel = md_path.as_posix()
        if source_rel.startswith("./"):
            source_rel = source_rel[2:]
        html_rel = "html/" + pathlib.PurePosixPath(source_rel).with_suffix(".html").as_posix()
        output_path = scan_dir / html_rel

        # Directory label for grouping
        parent = str(pathlib.PurePosixPath(source_rel).parent)
        directory = parent if parent != "." else "."

        entries.append({
            "title": title,
            "source_rel_path": source_rel,
            "html_rel_path": html_rel,
            "directory": directory,
        })

        # --- skip check (incremental) ---
        if not force and output_path.exists():
            src_mtime = md_path.stat().st_mtime
            out_mtime = output_path.stat().st_mtime
            if out_mtime >= src_mtime:
                skipped += 1
                continue

        # --- expensive conversion (only when needed) ---
        output_path.parent.mkdir(parents=True, exist_ok=True)

        md = _load_markdown_converter()
        body_html = md.convert(markdown_text)
        toc_html = md.toc  # type: ignore[attr-defined]

        depth_from_root = len(output_path.parent.relative_to(scan_dir).parts)
        index_url = "../" * depth_from_root + "index.html"

        depth_from_html = depth_from_root - 1
        content_styles_prefix = "../" * depth_from_html + "styles" if depth_from_html > 0 else "styles"

        html_content = _build_html(
            title=title,
            body_html=body_html,
            toc_html=toc_html,
            standalone=False,
            index_url=index_url,
            styles_prefix=content_styles_prefix,
        )
        output_path.write_text(html_content, encoding="utf-8")
        converted += 1

        print(f"  Converted: {source_rel} -> {html_rel}")

    # --- orphan detection ---
    expected_html = {e["html_rel_path"] for e in entries}
    styles_dir_resolved = styles_dest.resolve()
    orphan_entries: List[dict] = []

    for html_path in output_dir.rglob("*.html"):
        # Skip anything inside html/styles/
        try:
            if html_path.resolve().is_relative_to(styles_dir_resolved):
                continue
        except (ValueError, AttributeError):
            try:
                html_path.resolve().relative_to(styles_dir_resolved)
                continue
            except ValueError:
                pass

        rel = html_path.as_posix()
        if rel.startswith("./"):
            rel = rel[2:]

        if rel not in expected_html:
            orphan_title = _extract_title_from_html(html_path)
            parent = str(pathlib.PurePosixPath(rel).parent)
            directory = parent if parent != "." else "."
            orphan_entries.append({
                "title": orphan_title,
                "html_rel_path": rel,
                "directory": directory,
            })
            print(f"  Orphan: {rel} ({orphan_title})")

    # Generate site index at scan root
    index_path = scan_dir / "index.html"
    _build_site_index(entries, index_path, styles_prefix="html/styles",
                      orphan_entries=orphan_entries if orphan_entries else None)

    # Summary
    total = len(entries)
    if orphan_entries:
        print(f"\n  Found {len(orphan_entries)} orphaned HTML file{'s' if len(orphan_entries) != 1 else ''} (source .md deleted)")

    print(f"\nBuild complete: {converted} converted, {skipped} up-to-date, {total} total file{'s' if total != 1 else ''}.")
    if orphan_entries:
        print(f"  Orphans: {len(orphan_entries)} (listed in Deleted Files section of index)")
    print(f"  Index: {index_path}")
    print(f"  HTML:  {output_dir}/")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="make-web",
        description="Convert a Markdown file into a well-formatted HTML file.",
    )
    parser.add_argument("input", nargs="?", help="Path to the Markdown file")
    parser.add_argument(
        "-o",
        "--output",
        help="Output HTML path (default: input filename with .html)",
    )
    parser.add_argument(
        "--no-toc",
        action="store_true",
        help="Disable table of contents",
    )
    parser.add_argument(
        "--standalone",
        action="store_true",
        help="Generate self-contained HTML with inline CSS",
    )
    parser.add_argument(
        "--badge",
        default="Documentation",
        help="Header badge text (default: Documentation)",
    )
    parser.add_argument(
        "--subtitle",
        help="Page subtitle (default: from config or 'Generated by Make Web')",
    )
    parser.add_argument(
        "--index-url",
        help="URL for the 'Notes Index' nav link (omit to hide nav)",
    )
    parser.add_argument(
        "--buildsite",
        action="store_true",
        help="Batch mode: scan cwd for .md files, convert all to html/ and generate index.html",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force reconversion of all files (ignore mtime, only with --buildsite)",
    )
    args = parser.parse_args()

    # Validate required paths before processing
    if not validate_paths():
        return 1

    # Buildsite mode: batch convert all .md files in cwd
    if args.buildsite:
        return build_site(force=args.force)

    if not args.input:
        parser.error("the following arguments are required: input (or use --buildsite)")

    input_path = pathlib.Path(args.input)
    if not input_path.exists():
        print(f"Input file not found: {input_path}", file=sys.stderr)
        return 1

    markdown_text = input_path.read_text(encoding="utf-8")
    title = _infer_title(markdown_text, input_path.stem)

    try:
        md = _load_markdown_converter()
    except RuntimeError as exc:
        print(str(exc), file=sys.stderr)
        return 1

    body_html = md.convert(markdown_text)
    toc_html = None if args.no_toc else md.toc  # type: ignore[attr-defined]

    output_path = pathlib.Path(args.output) if args.output else input_path.with_suffix(".html")

    # Copy styles/ next to output (skip in standalone mode)
    if not args.standalone:
        output_styles_dir = output_path.parent / "styles"
        shutil.copytree(STYLES_SRC_DIR, output_styles_dir, dirs_exist_ok=True)

    html_content = _build_html(
        title=title,
        body_html=body_html,
        toc_html=toc_html,
        standalone=args.standalone,
        badge=args.badge,
        subtitle=args.subtitle,
        index_url=args.index_url,
    )

    output_path.write_text(html_content, encoding="utf-8")

    print(f"Wrote: {output_path}")
    if args.standalone:
        print("  (Standalone mode - CSS inlined)")
    else:
        print(f"  Styles copied to: {output_path.parent / 'styles'}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
